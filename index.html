<!DOCTYPE html>
<html>
<head>
    <title>Twin3Demo - Web3 èº«åˆ†é©—è­‰ç³»çµ±</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px; }
        .container { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
        button { background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #45a049; }
        button:disabled { background: #cccccc; cursor: not-allowed; }
        .status { margin: 10px 0; padding: 10px; background: #e7f3ff; border-radius: 5px; }
        .error { background: #ffebee; color: #c62828; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .verify-btn { background: #2196F3; }
        .verify-btn:hover { background: #1976D2; }
    </style>
</head>
<body>
    <h1>ğŸ”— Twin3Demo - Web3 èº«åˆ†é©—è­‰ç³»çµ±</h1>
    
    <div class="container">
        <h2>éŒ¢åŒ…é€£æ¥</h2>
        <button id="connectBtn" onclick="connectWallet()">é€£æ¥ MetaMask</button>
        <div id="walletStatus" class="status">è«‹å…ˆé€£æ¥éŒ¢åŒ…</div>
    </div>

    <div class="container">
        <h2>èº«åˆ†NFT (ERC-4671)</h2>
        <button id="mintBtn" onclick="mintNFT()" disabled>é‘„é€ èº«åˆ†NFT</button>
        <button id="checkNFTBtn" onclick="checkNFT()" disabled>æŸ¥è©¢NFTé¤˜é¡</button>
        <div id="nftStatus" class="status">è«‹å…ˆé€£æ¥éŒ¢åŒ…</div>
    </div>

    <div class="container">
        <h2>çå‹µToken (ERC-20)</h2>
        <h4>æ­¤åŠŸèƒ½åƒ…ä½œç¤ºç¯„ï¼Œæ•…ç„¡é™åˆ¶é ˜å¹¾é¡†ï¼Œå»ºè­°å…ˆå»faucet(https://www.kaia.io/faucet)é ˜æ¸¬è©¦å¹£</h4>
        <button id="rewardBtn" onclick="claimReward()" disabled>é ˜å–çå‹µToken</button>
        <button id="checkTokenBtn" onclick="checkToken()" disabled>æŸ¥è©¢Tokené¤˜é¡</button>
        <div id="tokenStatus" class="status">è«‹å…ˆé€£æ¥éŒ¢åŒ…</div>
    </div>

    <script src="./ethers.min.js"></script>
    <script>
        // åˆç´„åœ°å€
        const IDENTITY_ADDR = "0x964f9eE660416a6A70c77Eae4cDcF331a18d8723";
        const REWARD_ADDR = "0x1E129567ce4B43DecD71410cebA77a3CD3dE0A33";
        
        // åˆç´„ABIï¼ˆç°¡åŒ–ç‰ˆï¼‰
        const IDENTITY_ABI = [
            "function mint() external",
            "function balanceOf(address owner) view returns (uint256)",
            "function name() view returns (string)"
        ];
        
        const REWARD_ABI = [
            "function claimReward() external",
            "function balanceOf(address owner) view returns (uint256)",
            "function name() view returns (string)"
        ];

        let provider, signer, userAddress;
        let identityContract, rewardContract;
        let authToken = null;
        const API_BASE = 'http://localhost:3001/api';

        // é é¢è¼‰å…¥æ™‚æª¢æŸ¥ MetaMask
        window.addEventListener('load', async () => {
            if (typeof window.ethereum !== 'undefined') {
                console.log('MetaMask is available!');
            } else {
                console.log('Please install MetaMask!');
            }
        });

        async function connectWallet() {
            try {
                // ç­‰å¾… MetaMask æ³¨å…¥
                if (typeof window.ethereum === 'undefined') {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                if (typeof window.ethereum !== 'undefined') {
                    console.log('MetaMask detected:', window.ethereum);
                    
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    
                    // è«‹æ±‚å¸³æˆ¶å­˜å–
                    const accounts = await provider.send("eth_requestAccounts", []);
                    console.log('Accounts:', accounts);
                    
                    signer = provider.getSigner();
                    userAddress = await signer.getAddress();
                    
                    identityContract = new ethers.Contract(IDENTITY_ADDR, IDENTITY_ABI, signer);
                    rewardContract = new ethers.Contract(REWARD_ADDR, REWARD_ABI, signer);
                    
                    document.getElementById('walletStatus').innerHTML = `
                        ğŸ”— å·²é€£æ¥: ${userAddress.slice(0,6)}...${userAddress.slice(-4)}
                        <br><button id="verifyBtn" class="verify-btn" onclick="verifyWallet()">é©—è­‰éŒ¢åŒ…æ‰€æœ‰æ¬Š</button>
                        <div id="verifiedStatus" style="display:none;">âœ… éŒ¢åŒ…å·²é©—è­‰</div>
                    `;
                    
                    // å•Ÿç”¨æŒ‰éˆ•
                    document.getElementById('mintBtn').disabled = false;
                    document.getElementById('rewardBtn').disabled = false;
                    document.getElementById('checkNFTBtn').disabled = false;
                    document.getElementById('checkTokenBtn').disabled = false;
                    
                    // è‡ªå‹•æŸ¥è©¢é¤˜é¡
                    checkNFT();
                    checkToken();
                } else {
                    throw new Error('MetaMask not detected');
                }
            } catch (error) {
                console.error('Connection error:', error);
                if (error.code === 4001) {
                    document.getElementById('walletStatus').innerHTML = 'âŒ ç”¨æˆ¶æ‹’çµ•é€£æ¥';
                } else {
                    document.getElementById('walletStatus').innerHTML = 'âŒ è«‹å®‰è£ MetaMask éŒ¢åŒ…';
                }
                document.getElementById('walletStatus').className = 'status error';
            }
        }

        // éŒ¢åŒ…é©—è­‰åŠŸèƒ½
        async function verifyWallet() {
            try {
                if (!userAddress) {
                    alert('è«‹å…ˆé€£æ¥éŒ¢åŒ…');
                    return;
                }
                
                document.getElementById('walletStatus').innerHTML = 'â³ æ­£åœ¨ç²å–é©—è­‰è¨Šæ¯...';
                
                // 1. ç²å– nonce
                const nonceResponse = await fetch(`${API_BASE}/auth/nonce`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: userAddress })
                });
                
                if (!nonceResponse.ok) {
                    throw new Error(`HTTP ${nonceResponse.status}: ${nonceResponse.statusText}`);
                }
                
                const { message } = await nonceResponse.json();
                
                // 2. è«‹æ±‚ç”¨æˆ¶ç°½å
                document.getElementById('walletStatus').innerHTML = 'â³ è«‹åœ¨éŒ¢åŒ…ä¸­ç°½åé©—è­‰...';
                const signature = await signer.signMessage(message);
                
                // 3. æäº¤ç°½åé©—è­‰
                document.getElementById('walletStatus').innerHTML = 'â³ æ­£åœ¨é©—è­‰ç°½å...';
                const verifyResponse = await fetch(`${API_BASE}/auth/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: userAddress, signature })
                });
                
                if (!verifyResponse.ok) {
                    const errorData = await verifyResponse.json();
                    throw new Error(errorData.error || `HTTP ${verifyResponse.status}`);
                }
                
                const result = await verifyResponse.json();
                
                if (result.success) {
                    authToken = result.token;
                    document.getElementById('walletStatus').innerHTML = `
                        âœ… éŒ¢åŒ…é©—è­‰æˆåŠŸï¼<br>
                        ğŸ¯ èº«åˆ†NFTæ•¸é‡: ${result.nftBalance}<br>
                        ğŸ” å·²å»ºç«‹å®‰å…¨ç™»å…¥ç‹€æ…‹
                    `;
                    document.getElementById('walletStatus').className = 'status success';
                    
                    // éš±è—é©—è­‰æŒ‰éˆ•ï¼Œé¡¯ç¤ºå·²é©—è­‰ç‹€æ…‹
                    const verifyBtn = document.getElementById('verifyBtn');
                    const verifiedStatus = document.getElementById('verifiedStatus');
                    if (verifyBtn) verifyBtn.style.display = 'none';
                    if (verifiedStatus) verifiedStatus.style.display = 'block';
                } else {
                    throw new Error(result.error || 'é©—è­‰å¤±æ•—');
                }
                
            } catch (error) {
                console.error('é©—è­‰å¤±æ•—:', error);
                document.getElementById('walletStatus').innerHTML = `âŒ éŒ¢åŒ…é©—è­‰å¤±æ•—: ${error.message}`;
                document.getElementById('walletStatus').className = 'status error';
            }
        }

        // ä¿®å¾©çš„é‘„é€ NFTå‡½æ•¸
        async function mintNFT() {
            try {
                // å…ˆæª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²ç¶“æŒæœ‰NFT
                const balance = await identityContract.balanceOf(userAddress);
                if (balance.gt(0)) {
                    document.getElementById('nftStatus').innerHTML = 'âœ… æ‚¨å·²ç¶“æŒæœ‰èº«åˆ†NFTï¼Œç„¡éœ€é‡è¤‡é‘„é€ ';
                    document.getElementById('nftStatus').className = 'status success';
                    return;
                }
                
                document.getElementById('nftStatus').innerHTML = 'â³ æ­£åœ¨é‘„é€ èº«åˆ†NFT...';
                const tx = await identityContract.mint();
                await tx.wait();
                document.getElementById('nftStatus').innerHTML = 'âœ… èº«åˆ†NFTé‘„é€ æˆåŠŸ!';
                document.getElementById('nftStatus').className = 'status success';
                setTimeout(checkNFT, 2000);
            } catch (error) {
                console.error(error);
                if (error.message.includes('Already minted')) {
                    document.getElementById('nftStatus').innerHTML = 'âœ… æ‚¨å·²ç¶“æŒæœ‰èº«åˆ†NFT';
                    document.getElementById('nftStatus').className = 'status success';
                } else {
                    document.getElementById('nftStatus').innerHTML = `âŒ é‘„é€ å¤±æ•—: ${error.message}`;
                    document.getElementById('nftStatus').className = 'status error';
                }
            }
        }

        async function claimReward() {
            try {
                document.getElementById('tokenStatus').innerHTML = 'â³ æ­£åœ¨é ˜å–çå‹µToken...';
                const tx = await rewardContract.claimReward();
                await tx.wait();
                document.getElementById('tokenStatus').innerHTML = 'âœ… çå‹µTokené ˜å–æˆåŠŸ!';
                document.getElementById('tokenStatus').className = 'status success';
                setTimeout(checkToken, 2000);
            } catch (error) {
                console.error(error);
                document.getElementById('tokenStatus').innerHTML = `âŒ é ˜å–å¤±æ•—: ${error.message}`;
                document.getElementById('tokenStatus').className = 'status error';
            }
        }

        // ä¿®å¾©çš„æŸ¥è©¢NFTå‡½æ•¸
        async function checkNFT() {
            try {
                document.getElementById('nftStatus').innerHTML = 'â³ æŸ¥è©¢ä¸­...';
                const balance = await identityContract.balanceOf(userAddress);
                const name = await identityContract.name();
                document.getElementById('nftStatus').innerHTML = `ğŸ“Š ${name} æŒæœ‰æ•¸é‡: ${balance.toString()}`;
                document.getElementById('nftStatus').className = 'status';
            } catch (error) {
                console.error('æŸ¥è©¢NFTé¤˜é¡éŒ¯èª¤:', error);
                document.getElementById('nftStatus').innerHTML = `âŒ æŸ¥è©¢å¤±æ•—: ${error.message}`;
                document.getElementById('nftStatus').className = 'status error';
            }
        }

        async function checkToken() {
            try {
                const balance = await rewardContract.balanceOf(userAddress);
                const name = await rewardContract.name();
                const formatted = ethers.utils.formatEther(balance);
                document.getElementById('tokenStatus').innerHTML = `ğŸ“Š ${name} é¤˜é¡: ${formatted} Token`;
                document.getElementById('tokenStatus').className = 'status';
            } catch (error) {
                console.error(error);
                document.getElementById('tokenStatus').innerHTML = `âŒ æŸ¥è©¢å¤±æ•—: ${error.message}`;
                document.getElementById('tokenStatus').className = 'status error';
            }
        }
    </script>
</body>
</html>
